<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Codebase Call Graph (Dark Mode)</title>
  <!-- Highlight.js CSS for dark mode (using Atom One Dark theme) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
  <style>
    /* Dark Mode Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      background: #1f1f1f;
      color: #e0e0e0;
      padding: 10px 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    #controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #search-input {
      padding: 6px 8px;
      border: none;
      border-radius: 4px;
      font-size: 0.9em;
      width: 200px;
    }
    /* Add datalist styling if needed */
    datalist option {
      font-size: 0.9em;
    }
    #graph-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100%;
      background: #1e1e1e;
    }
    .node {
      stroke: #121212;
      stroke-width: 1.5px;
      cursor: pointer;
    }
    .link {
      stroke: #555;
      stroke-opacity: 0.6;
    }
    .labels text {
      font-size: 12px;
      fill: #e0e0e0;
      pointer-events: none;
    }
    /* Code display panel - hidden by default */
    #code-display {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 35%;
      height: 80%;
      overflow-y: auto;
      background: #1e1e1e;
      border: 1px solid #333;
      padding: 10px;
      font-family: "Courier New", Courier, monospace;
      box-shadow: 0 2px 5px rgba(0,0,0,0.7);
      z-index: 10;
      display: none;
    }
    #code-display pre {
      margin: 0;
      padding: 0;
    }
    .metadata {
      background: #2e2e2e;
      border-bottom: 1px solid #444;
      padding: 5px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <header>
    <div>Codebase Call Graph (Dark Mode)</div>
    <div id="controls">
      <input type="text" id="search-input" placeholder="Search functions..." list="search-suggestions">
      <datalist id="search-suggestions"></datalist>
    </div>
  </header>
  <div id="graph-container">
    <svg></svg>
    <div id="code-display">
      <!-- Code details will be displayed here on node selection -->
    </div>
  </div>

  <!-- Include D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Include Highlight.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>
    hljs.highlightAll();

    // Global variables for simulation and selections
    const svg = d3.select("svg");
    const container = svg.append("g");
    let simulation, link, node, labels;
    let allNodes = [], allLinks = [];
    
    // Setup zoom behavior.
    const zoom = d3.zoom()
      .scaleExtent([0.2, 5])
      .on("zoom", (event) => {
        container.attr("transform", event.transform);
      });
    svg.call(zoom);

    // Fetch the call graph data from the Flask endpoint.
    fetch('/data')
      .then(response => response.json())
      .then(data => {
        const nodes = [];
        const nodeSet = new Set();
        const links = [];
        
        // Build nodes and links arrays.
        for (const func in data) {
          nodeSet.add(func);
          data[func].calls.forEach(calledFunc => {
            nodeSet.add(calledFunc);
            links.push({ source: func, target: calledFunc });
          });
        }
        nodeSet.forEach(funcName => {
          nodes.push({ 
            id: funcName, 
            code: data[funcName] ? data[funcName].code : "No code available",
            file: data[funcName] ? data[funcName].file : "Unknown file",
            breadcrumbs: data[funcName] ? data[funcName].breadcrumbs : "No breadcrumbs"
          });
        });
        allNodes = nodes;
        allLinks = links;
        
        // Populate datalist with all function names.
        const datalist = document.getElementById("search-suggestions");
        nodes.forEach(n => {
          const option = document.createElement("option");
          option.value = n.id;
          datalist.appendChild(option);
        });
        
        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;
        
        // Create force simulation.
        simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance(150))
          .force("charge", d3.forceManyBody().strength(-400))
          .force("center", d3.forceCenter(width / 2, height / 2));
        
        // Draw links.
        link = container.append("g")
            .attr("class", "links")
          .selectAll("line")
          .data(links)
          .enter().append("line")
            .attr("class", "link")
            .attr("stroke-width", 1.5);
        
        // Draw nodes.
        node = container.append("g")
            .attr("class", "nodes")
          .selectAll("circle")
          .data(nodes)
          .enter().append("circle")
            .attr("class", "node")
            .attr("r", 10)
            .attr("fill", "#69b3a2")
            .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended))
            .on("click", function(event, d) {
              showNodeDetails(d);
              zoomToNode(d);
            });
        
        // Draw labels.
        labels = container.append("g")
            .attr("class", "labels")
          .selectAll("text")
          .data(nodes)
          .enter().append("text")
            .attr("dy", -15)
            .attr("text-anchor", "middle")
            .text(d => d.id);
        
        simulation.on("tick", () => {
          link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);
          node
              .attr("cx", d => d.x)
              .attr("cy", d => d.y);
          labels
              .attr("x", d => d.x)
              .attr("y", d => d.y);
        });
      });
    
    // Function to show details in the code display panel.
    function showNodeDetails(d) {
      const codeDisplay = document.getElementById("code-display");
      codeDisplay.style.display = "block";
      codeDisplay.innerHTML = `
        <div class="metadata">
          <strong>File:</strong> ${d.file}<br>
          <strong>Path:</strong> ${d.breadcrumbs}
        </div>
        <pre><code class="python">${d.code}</code></pre>
      `;
      hljs.highlightElement(document.querySelector("#code-display pre code"));
    }
    
    // Function to smoothly zoom into a node.
    function zoomToNode(d) {
      const svgEl = svg.node();
      const width = svgEl.clientWidth;
      const height = svgEl.clientHeight;
      const scale = 2; // desired zoom scale
      const x = d.x;
      const y = d.y;
      // Compute new transform.
      const translate = [width / 2 - scale * x, height / 2 - scale * y];
      svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }
    
    // Search functionality.
    const searchInput = document.getElementById("search-input");
    // On change event: exact match behavior.
    searchInput.addEventListener("change", () => {
      const query = searchInput.value.trim().toLowerCase();
      const exactMatch = allNodes.find(n => n.id.toLowerCase() === query);
      if (exactMatch) {
        // Show details and zoom to exact match.
        showNodeDetails(exactMatch);
        zoomToNode(exactMatch);
        // Highlight the exact node.
        node.attr("fill", d => d.id.toLowerCase() === query ? "#007bff" : "#69b3a2")
            .attr("r", d => d.id.toLowerCase() === query ? 20 : 10)
            .attr("opacity", d => d.id.toLowerCase() === query ? 1 : 0.2);
        link.attr("opacity", d => (d.source.id.toLowerCase() === query || d.target.id.toLowerCase() === query) ? 1 : 0.1);
      }
    });
    
    // On keyup event: if no exact match, apply partial filtering.
    searchInput.addEventListener("keyup", () => {
      const query = searchInput.value.trim().toLowerCase();
      const exactMatches = allNodes.filter(n => n.id.toLowerCase() === query);
      if (query && exactMatches.length === 1) {
        // If there's an exact match, highlight it.
        node.attr("fill", d => d.id.toLowerCase() === query ? "#007bff" : "#69b3a2")
            .attr("r", d => d.id.toLowerCase() === query ? 20 : 10)
            .attr("opacity", d => d.id.toLowerCase() === query ? 1 : 0.2);
        link.attr("opacity", d => (d.source.id.toLowerCase() === query || d.target.id.toLowerCase() === query) ? 1 : 0.1);
      } else {
        // Otherwise, perform partial matching.
        node.attr("fill", "#69b3a2")
            .attr("opacity", d => d.id.toLowerCase().includes(query) ? 1 : 0.2)
            .attr("r", d => d.id.toLowerCase().includes(query) ? 15 : 10);
        link.attr("opacity", d => (d.source.id.toLowerCase().includes(query) || d.target.id.toLowerCase().includes(query)) ? 1 : 0.1);
      }
    });
    
    // Drag event functions.
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
  </script>
</body>
</html>
